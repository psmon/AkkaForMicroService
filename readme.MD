
# Akka.net for MicroService

 모든 응용 프로그램은 시간에 따라 진화합니다. 성공적인 응용 프로그램은 사람들에게 유용하게 되어 진화합니다. 실패한 응용 프로그램은 진화하지 않고 결국은 퇴출됩니다.
란 컨셉하에, 많은 기능을 가진 단일 서비스보다 여러가지 기능을 나누어 가지고 진화가 쉬운 마이크로 서비스란 개념이 생기기 시작하였습니다.
Java 진영에서 Akka를 통해 마이크로 서비스를 시도하였으며 , 마이크로 서비스에서 요구하는 애매모호한 이상적인 컨셉을 
Akka.net을 이용해 Code단위로 Any Test MicroService 를 구현하면서, MicroService의 이상적인 개념을 테스트 코드를 통해 파악예정입니다.


![그림](https://docs.microsoft.com/ko-kr/azure/service-fabric/media/service-fabric-overview-microservices/monolithic-vs-micro.png)


## 모놀리스(덩어리) 아키텍처

모놀리스 방식의 소프트웨어에서는 주로 3계층(3-tier) 아키텍처를 사용 합니다.

* 프리젠테이션 계층
* 비즈니스 계층
* 데이터 접근 계층

전통적인 웹 애플리케이션 클라이언트(브라우저)가 요청을 전송했다고 가정 해봅시다.  비즈니스 계층은 비즈니스 로직을 실행하고, 데이터베이스에서 특정 데이터를 불러오고/저장하고, UI를 통해 데이터를 사용자에게 보여줍니다.


특징
* 동일한 서비스에서 포함하는 모듈(Dll)을 호출하기때문에 디버깅및 호출이 빠르다
* 통합된 로컬개발환경 구축이 가능하나, 작은 기능개선을 위해 모두 구축해야 되는 경우가 있다.


문제점
* 하나의 코드베이스인체로 코드가 점차적으로 증가합니다. UI 개발자, 비즈니스 계층 개발자를 불문하고 모든 개발자는 같은 코드 베이스 내에서 커밋을 하며 코드를 관리하는 것이 매우 비효율적이 되어버립니다.
* 하나의 코드 베이스에서 모듈은 서로 의존적이기 때문에 한개의 모듈안에서 최소의 변경 사항도 모든 아티팩트를 생성하고  분산된 각 서버풀에 배포 해야합니다.
* 세 개의 다기능 팀이 3계층 아키텍처를 사용하는 모놀리스 방식의 소프트웨어에 추가 될 한 가지 기능 개발에 참여하고 있습니다. 비록 3계층 아키텍처가 책임의 분리를 제공함에도 불구하고 장기적인 관점에서는 경계는 서로 겹치게되고 계층은 유연함을 잃고 경직되게 됩니다.


## 마이크로 서비스 아키텍쳐

특징
* 개발을 위해 모든 개발환경을 셋팅할 필요가 없다.
* 작은 서비스(service)들의 집합으로써 애플리케이션(monolithic application)을 개발하는 방법이다.
* 서비스들이 각각 프로세스이고 가벼운 통신 메커니즘을 사용한다.
* 자동화된 방법으로 독립적으로 배포될 수 있다. 
* 서비스들을 위해 최소한의 중앙 관리를 사용한다. 
* 서비스들은 다른 프로그래밍 언어로 개발될 수 있고, 다른 데이터 저장 기술을 사용할 수도 있다.


## 마이크로 서비스로 전환시 어려운점

* 확장을 위해 코드와 상태를 파티션(또는 분할) 방법을 이해하는 것은 어렵습니다.
* 전체 도메인에서 가장 작은 기능 단위로 서비스를 정의하는것도 어려움
* 파편화된 작은 단위로 만든 서비스의 수명/유지/관리 문제 역시 어려움
* 마이크로 서비스로의 전환은 단점이 아니라, 어렵다는데 있습니다. 



## Akka가 MicroService를 위해 준비 해놓은것들
* 개체접근이 Local에서만 자유로운 Class(OOP)방식의 설계가아닌, 애시당초 메시지 기반의 Actor를 설계함
* 만들어진 Actor는 어디든지 배치가 가능하다. ( 서비스 종속성이 애시당초 없음 )
* System은 Actor를 포함할수 있으며 , System의 이름을 알면 어느 Actor건 접근이 가능하다. ( 리모트 액터 )
* System은 Roles 정의가 가능하며 , 그롤에 따라 클러스터 방식을 결정할수 있다.( 단지 옵션 설정만으로...)



